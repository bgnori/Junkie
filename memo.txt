

project name junkie
廃人

Goal
 非同期書き込み非同期読み込み、重複contentなしのtumblr client


作る話:
 pythonを使う
 なんでもいいのだがプラットフォームを選ぶのは嫌だ。
  Qt, wxpython とかか？

 - Downloading PyQt-x11-gpl-4.8.6.tar.gz (9.7Mb): 9.7Mb downloaded
  packagingがおかしくてinstallに失敗する。

 - wxpythonをyumでinstall してwx htmlとか



同期でsingle windowのclientを試作する。


pumblrはいいのかもしれないが、非同期じゃない。
modelの部分を作るためにtubmrl apiを理解する上で読むのはおおいにあり。
=> かなりシンプル。


http://www.tumblr.com/docs/en/api
http://lxml.de/xpathxslt.html

xmlを連結し、styleを入れてブラウザでレンダリングというモデルにするのか,
それともpostごとにレンダリングしてpaneとみなすべきなのか。


renderするときに使うデータをprefetchすればいい。
別processにする？fetcherともいうべきかな
ローカルのファイルもしくはメモリで保持。

 方針：
  - requestに充分先行してfetchをかける。
  - requestしたときに手元にないものは諦める。

 - requestしたものが使えるようになるまでの時間を記録して予測に使えるようにすべきだろう。
  ざっくりと見た感じでは、
   xx.media.tumblrは速い。1s以内 i.e. 25.media.tumblr.com => akamai.
   www.tumblr.com/photo...は遅い。 => 本家
  とりあえず3秒前に読み込め。

 - wx.html.windowの仕様でfileからしかimgを読み込めないようだ。
   とりあえずメモリ渡しはできないように見える。
   
 - renderを作るのがよいか？


twitterのpicsはa hrefで参照されているがこれも解決してembedするほうがよいだろう。
-> そういうことはいっぱいあるのではないか？
 need to name this idea. expand?

htmlのsubsetだが相当「方言」になるなぁ。mark upとして整ってもいないだろう。


fetchするときのUAとかAcceptとか・・・まああとでいいでしょう。


postのidでpostをdictにほうりこんで管理。
time-stampでも管理したい。(シーケンシャルな取得)
 heapqにするか？


Junkie's Guideにいれること。
http://www.kurihama-alcoholism-center.jp/tiar/


twisted.webにあるproxyを起点にするのが良さそう。



----------------------------------------
in proxy.py
from twisted.web import proxy, http
class ProxyFactory(http.HTTPFactory):
    protocol = proxy.Proxy
----------------------------------------
in twisted/web/proxy.py
class Proxy(HTTPChannel):
    requestFactory = ProxyRequest
----------------------------------------
うーん、HTTPChannel classがもっているclass memberをみたほうが良さそう。
----------------------------------------
親クラスは、LineReceiver

http://twistedmatrix.com/documents/11.0.0/api/twisted.protocols.basic.LineReceiver.html
A protocol that receives lines and/or raw data, depending on mode.

In line mode, each line that's received becomes a callback to lineReceived. In
raw data mode, each chunk of raw data becomes a callback to rawDataReceived.
The setLineMode and setRawMode methods switch between the two modes.


さらに元をたどると、IProtocolを実装している。
http://twistedmatrix.com/documents/11.0.0/api/twisted.internet.interfaces.IProtocol.html
IProtocol(Interface)
def dataReceived(data): (source) 
def connectionLost(reason): (source) 
def makeConnection(transport): (source)
def connectionMade(): (source)

call graphのようなものが欲しいのだが・・・


class Request:
    def requestReceived(self, command, path, version):
   	... 
        self.process()

class ProxyRequest(Request):
    def process(self):
が差分。


        class_ = self.protocols[protocol]
        clientFactory = class_(self.method, rest, self.clientproto, headers,
                               s, self)

とかなんだろう？
protocolは'http'という文字列。
    protocols = {'http': ProxyClientFactory}
なので、ProxyFactoryをみればいい。



class ProxyClientFactory(ClientFactory):
    protocol = ProxyClient
で大半はProxyClient転送されている。
ProxyClient自体に手をいれるのではなく、継承してPrefetchProxyClientでも実装して、
ごにょごにょですかね。
=>> ProxyRequestのようだ。


手を入れたときのログ。 stdout自体がhookされている模様。

2011-11-19 19:46:42+0900 [-] Log opened.
2011-11-19 19:46:42+0900 [-] __main__.PrefetchProxyFactory starting on 8080
2011-11-19 19:46:42+0900 [-] Starting factory <__main__.PrefetchProxyFactory instance at 0x191ff38>
2011-11-19 19:46:50+0900 [PrefetchProxy,0,127.0.0.1] http://www.tumblr.com/dashboard
2011-11-19 19:46:50+0900 [PrefetchProxy,0,127.0.0.1] www.tumblr.com
2011-11-19 19:46:50+0900 [PrefetchProxy,0,127.0.0.1] plug in
2011-11-19 19:46:50+0900 [PrefetchProxy,0,127.0.0.1] Starting factory <__main__.PrefetchProxyClientFactory instance at 0x1d29320>
2011-11-19 19:46:51+0900 [PrefetchProxyClient,client] 127.0.0.1 - - [19/Nov/2011:10:46:50 +0000] "GET http://www.tumblr.com/dashboard HTTP/1.1" 200 13464 "http://www.tumblr.com/tagged/animals" "Mozilla/5.0 (X11; Linux x86_64; rv:8.0) Gecko/20100101 Firefox/8.0"
2011-11-19 19:46:51+0900 [PrefetchProxyClient,client] Stopping factory <__main__.PrefetchProxyClientFactory instance at 0x1d29320>


「コンピュータサイエンスに難問は二つしかない。それは概念に名前をつけることと、キャッシュの失効である」
- Phil Karlton
There is also a variation on this that says there are two hard things in
computer science: cache invalidation, naming things, and off-by-one errors.


あ・・・postfixの設計間違えた。
おとなしく正規表現にしておけばよかった。
てかやりすぎ。


dashboardをサポートしたい。

junkie.pyにprefetchの指示を生成する機能を入れるべきかな？
ajaxのrequestにhookすればよさげ
 "GET http://abacus.tumblr.com/check_for_new_posts/a0146229bf7e844f190e2fcaecc47ab9.js?1321833330624 HTTP/1.1" 
 200 26 "http://www.tumblr.com/dashboard" "Mozilla/5.0 (X11; Linux x86_64; rv:8.0) Gecko/20100101 Firefox/8.0"

これはplugins/tumblr.pyのほうがよいのか？
 a) junkie.pyだとprocess間通信が発生
 b) plugin内だと/api/readを待つのが困る。
b)は致命的。

postの情報を追記で溜め込むのでcontrolが必要。

jsのcodeを見ると、こんな感じなので10分に一回か、一分に一回チェックしている
      this request genereted by following code in dashboard.html:
        var check_for_new_posts_url = 'http://abacus.tumblr.com/check_for_new_posts/a0146229bf7e844f190e2fcaecc47ab9.js';
        check_for_new_posts(60000);
time.time()の差を見る限り、90秒ごとに見える。


/api/dashboard, /api/write対応
POST queryに含まれる認証情報を吸い出す
 email
 password
 => 最初のloginを捕まえないとだめ。なのでcookieを覗き見る

 generator: これは別途必要。

postの内容は不明だが、これで名前をチェックする。
http://www.tumblr.com/check_if_tumblelog_name_is_available


      client.getPage('http://www.tumblr.com/dashboard', headers=myheaders)\
はheaderを任意に指定できるくせに、responseじゃなくて、bodyだけをCallbackに渡す。

getPageのかわりにgetResponseをhackする。
bodyをうまく処理できないので、downloadPageを使ったら、今度はheaderがこわされるらしく、login扱いにならない。


class HTTPPageGetter(http.HTTPClient):
の
    def connectionMade(self):
で、
            if key.lower() not in self._specialHeaders:
                # we calculated it on our own
                self.sendHeader(key, value)
とか・・・
    _specialHeaders = set(('host', 'user-agent', 'cookie', 'content-length'))
である。
hostはともかく、uaとcookieが書き換わっている。
爆発しろ

browserで/api/dashboardにいってもgetなので蹴られる。



- urlは http://www.tumblr.com/api/dashboard
- methodはPOSTを使う。
- email/password

wiresharkで見た.getPageはContent-Type headerを自動では付けてくれない!
 headers = {'Content-Type': 'application/x-www-form-urlencoded'},




